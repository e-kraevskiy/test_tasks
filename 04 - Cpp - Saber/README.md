## Первое задание:

--- 
Напишите функцию, которая принимает на вход знаковое целое число и печатает его двоичное
представление, не используя библиотечных классов или функций.
---

```cpp
template <typename T>
void printIntBinary(T num) {
  int shifts_count = sizeof(T) * 8 - 2;
  T mask = static_cast<T>(1);
  mask <<= shifts_count;
  // Знаковый бит
  if (num < 0)
    std::cout << '1';
  else
    std::cout << '0';
  while (mask) {
    if (num & mask)
      std::cout << '1';
    else
      std::cout << '0';
    mask >>= 1;
  }
  std::cout << std::endl;
}
```
Принцип работы:
Для получения каждого бита используется маска, состоящая из одного поднятого бита. Это старший бит числа, после получения текущего бита маска сдвигается на бит влево, до тех пор, пока в маске есть биты (> 0).

## Второе задание:
--- 
Напишите функцию, удаляющую последовательно дублирующиеся символы в строке:
```cpp
void RemoveDups(char* str);
```
---

```cpp
void RemoveDups(char* str) {
  char* cur = str;
  char* last_unique = str;
  while (*cur != '\0') {
    if (*cur != *last_unique) *(++last_unique) = *cur;
    ++cur;
  }
  *(++last_unique) = '\0';
}
```

Принцип работы: два указателя
Первым идем по всей строке, второй указывает на последний уникальный элемент. 
Второй указатель сдвигается, когда его значение не совспадает с первым.

  
## Третье задание:
--- 
Реализуйте функции сериализации и десериализации двусвязного списка в бинарном формате в
файл. Алгоритмическая сложность решения должна быть меньше квадратичной. 
---

Реализация:
[.h file](https://github.com/e-kraevskiy/test_tasks/blob/develop/04%20-%20Cpp%20-%20Saber/list.h)
[.cpp file](https://github.com/e-kraevskiy/test_tasks/blob/develop/04%20-%20Cpp%20-%20Saber/list.cpp)

Сериализация:
1. Сначала записывается количество узлов списка.
2. Записывается размер data и сама data. 
3. Меняем prev у каждого узла на новый узел, data которого содержит индекс текущего узла.
4. Идем по списку, записываем в файл индекс узла, на который указвыает rand. Этот индекс лежит в cur->rand->prev->data (см. 3 пункт)
5. Проходим по списку и восстанавливаем prev для каждой ноды.

В общем по списку мы проходим 3 раза (пункты 2-3, 4, 5)
Следоватлеьно алгоритмическая сложность - O(n).

Десериализация:
1. Читаем колчисетво узлов.
2. Получаем размер data и саму data для каждого узла, после чего добавляем в список соответствующий узел.
3. Паралельно с п.2 заполняем вектор указателей на ноды.
4. Считываем индексы rand узлов, и заполняем prev значем из вектора указателей.

По списку мы идем два раза, поэтому сложность также - O(n).