## Первое задание:

--- 
На языке С/С++, написать алгоритм (функцию) определения четности целого числа, который будет аналогичен
нижеприведенному по функциональности, но отличен по своей сути.

Объяснить плюсы и минусы обеих реализаций.
```cpp
bool isEven(int value){return value % 2 == 0;}
```
---
```cpp
bool isEven(int value){return !(value & 1);} 
```
Принцип работы: у нечетного числа младший бит равен единице.
Маска проверяет выставление этого бита.
 
Плюсы первой реализации:
1. Читаемость
Плюсы второй реализации:
1. Эффективность, т.к. битовые операции выполняются быстрее деления
 
Однако скорость работы данных функций будет напрямую зависеть от используемого компилятора и его оптимизации. (При должной оптимизации разницы между ассемблерными командами быть не должно)
 
## Второе задание:
--- 
На языке С++, написать минимум по 2 класса реализовавших циклический буфер.

Объяснить плюсы и минусы каждой реализации.
 
---
 
[1. Реализация - на массиве](https://github.com/e-kraevskiy/test_tasks/blob/develop/03%20-%20Cpp/circular_buffer_array.h)
 
[2. Реализация - на связном списке](https://github.com/e-kraevskiy/test_tasks/blob/develop/03%20-%20Cpp/circular_buffer_list.h)
 
Первая реализация является более распространенной и простой. 
Преимуществом является постоянное расположение элементов буфера в памяти.
Вторая реализация требует дополнительной памяти для указателей узлов. И более медленная из-за постоянного доступа к элементам через указатели. 
Сложность вставки и удаления в обоих вариантах осуществляется за O(1).
 
Однако если рассматривать буфер динамического размера, то у второго варианта преимуществом является добавление дополнительного элемента за константное время.
 
## Третье задание:
--- 
На языке С/С++, написать функцию, которая быстрее всего (по процессорным тикам) отсортирует данный ей массив
чисел.Массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным).

Объяснить почему вы считаете, что функция соответствует заданным критериям.
 
---
Не существует универсальной сортировки для всех возможных случаев.
 
Можно выделить Heapsort, которая во всех случаях работает за nlogn и не использует дополнительной памяти. Однако она не устойчивая (stable), что может негативно повлиять при работе с большими объектами.
Timsort работать за nlogn в среднем и худшем случае, и за n операций в лучшем случае. Она также является устойчивой, но требует дополнительно n памяти. 
 
При выборе сортировки также стоит учитывать следующие параметры: 
1. Возможность использования параллельных вычислений.
2. Работа с соседними элементами при сортировке. Т.к. соседние элементы попадут в кеш. 
3. Сложность реализации\
 
А также те, который уже упоминались в примерах:
 
4. Работа в лучшем/худшем/среднем случае.
5. Использование дополнительной памяти. 
6. Влияние устойчивости сортировка на ее работу.
 
Т.к. в задании ничего не сказано о памяти, то в качестве ответа [приведу реализацию Timsort](https://github.com/e-kraevskiy/test_tasks/blob/develop/03%20-%20Cpp/timsort.h)
 
Также для большинства повседневных задач можно использовать std::sort, но нужно учитывать что ее реализация зависит от компилятора.
 

